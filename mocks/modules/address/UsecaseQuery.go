// Code generated by mockery v2.40.1. DO NOT EDIT.

package mocks

import (
	context "context"
	request "user-service/internal/modules/address/models/request"

	mock "github.com/stretchr/testify/mock"

	response "user-service/internal/modules/address/models/response"
)

// UsecaseQuery is an autogenerated mock type for the UsecaseQuery type
type UsecaseQuery struct {
	mock.Mock
}

// FindCities provides a mock function with given fields: origCtx, payload
func (_m *UsecaseQuery) FindCities(origCtx context.Context, payload request.City) (*response.CityResp, error) {
	ret := _m.Called(origCtx, payload)

	if len(ret) == 0 {
		panic("no return value specified for FindCities")
	}

	var r0 *response.CityResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, request.City) (*response.CityResp, error)); ok {
		return rf(origCtx, payload)
	}
	if rf, ok := ret.Get(0).(func(context.Context, request.City) *response.CityResp); ok {
		r0 = rf(origCtx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*response.CityResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, request.City) error); ok {
		r1 = rf(origCtx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindContinent provides a mock function with given fields: origCtx
func (_m *UsecaseQuery) FindContinent(origCtx context.Context) (*response.ContinentResp, error) {
	ret := _m.Called(origCtx)

	if len(ret) == 0 {
		panic("no return value specified for FindContinent")
	}

	var r0 *response.ContinentResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*response.ContinentResp, error)); ok {
		return rf(origCtx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *response.ContinentResp); ok {
		r0 = rf(origCtx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*response.ContinentResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(origCtx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindCountries provides a mock function with given fields: origCtx, payload
func (_m *UsecaseQuery) FindCountries(origCtx context.Context, payload request.Country) (*response.CountryResp, error) {
	ret := _m.Called(origCtx, payload)

	if len(ret) == 0 {
		panic("no return value specified for FindCountries")
	}

	var r0 *response.CountryResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, request.Country) (*response.CountryResp, error)); ok {
		return rf(origCtx, payload)
	}
	if rf, ok := ret.Get(0).(func(context.Context, request.Country) *response.CountryResp); ok {
		r0 = rf(origCtx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*response.CountryResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, request.Country) error); ok {
		r1 = rf(origCtx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindDistricts provides a mock function with given fields: origCtx, payload
func (_m *UsecaseQuery) FindDistricts(origCtx context.Context, payload request.District) (*response.DistrictResp, error) {
	ret := _m.Called(origCtx, payload)

	if len(ret) == 0 {
		panic("no return value specified for FindDistricts")
	}

	var r0 *response.DistrictResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, request.District) (*response.DistrictResp, error)); ok {
		return rf(origCtx, payload)
	}
	if rf, ok := ret.Get(0).(func(context.Context, request.District) *response.DistrictResp); ok {
		r0 = rf(origCtx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*response.DistrictResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, request.District) error); ok {
		r1 = rf(origCtx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindProvinces provides a mock function with given fields: origCtx, payload
func (_m *UsecaseQuery) FindProvinces(origCtx context.Context, payload request.Province) (*response.ProvinceResp, error) {
	ret := _m.Called(origCtx, payload)

	if len(ret) == 0 {
		panic("no return value specified for FindProvinces")
	}

	var r0 *response.ProvinceResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, request.Province) (*response.ProvinceResp, error)); ok {
		return rf(origCtx, payload)
	}
	if rf, ok := ret.Get(0).(func(context.Context, request.Province) *response.ProvinceResp); ok {
		r0 = rf(origCtx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*response.ProvinceResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, request.Province) error); ok {
		r1 = rf(origCtx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindSubDistricts provides a mock function with given fields: origCtx, payload
func (_m *UsecaseQuery) FindSubDistricts(origCtx context.Context, payload request.SubDistrict) (*response.SubDistrictResp, error) {
	ret := _m.Called(origCtx, payload)

	if len(ret) == 0 {
		panic("no return value specified for FindSubDistricts")
	}

	var r0 *response.SubDistrictResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, request.SubDistrict) (*response.SubDistrictResp, error)); ok {
		return rf(origCtx, payload)
	}
	if rf, ok := ret.Get(0).(func(context.Context, request.SubDistrict) *response.SubDistrictResp); ok {
		r0 = rf(origCtx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*response.SubDistrictResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, request.SubDistrict) error); ok {
		r1 = rf(origCtx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewUsecaseQuery creates a new instance of UsecaseQuery. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUsecaseQuery(t interface {
	mock.TestingT
	Cleanup(func())
}) *UsecaseQuery {
	mock := &UsecaseQuery{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
